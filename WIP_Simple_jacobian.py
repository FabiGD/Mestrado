import yaml
import julia
import os
import pandas as pd
import matplotlib.pyplot as plt
import pickle
import numpy as np
import time

from julia import Main
from matplotlib.ticker import ScalarFormatter

class OPENBF_Jacobian:
    """
            Creates the Jacobian matrix for a parameter variation of a vessel.

            Attributes:
            ----------

            base_file: str
                Path of the .yaml file to be updated.
            updated_file: str
                Path of the updated .yaml file.

                The .yaml file of the output_file does not need to exist previously, but the directory does.
                The inlet file needs to be in the same directory.
            openBF_dir: str
                Path of the directory where the .last files (openBF output) will be stored.
                The final folder of the directory does not need to exist previously.
            """
    def __init__(self, patient_file, k0_file, openBF_dir):
        self.patient_file = patient_file
        self.k0_file = k0_file # Is not used, but needs to exist
        self.openBF_dir = openBF_dir


    def update_yaml(self, knumber, vase, parameter, add_value):

        self.add_value = add_value
        updated_file = os.path.join(openBF_dir, f"updated_{parameter}.yaml")

        # Loads YAML from k_file
        if knumber == 0:
            k_file = os.path.join(openBF_dir, self.k0_file)
        else:
            k_file = os.path.join(openBF_dir, f"problema_inverso - k={knumber}.yaml")
        with open(k_file, "r", encoding="utf-8") as f:
            yaml_data = yaml.safe_load(f) or {}

        if "network" not in yaml_data:
            print("Error: The 'network' key was not found in the YAML.")
            return

        found = False  # Flag to know if the vase was found

        for item in yaml_data["network"]:
            print(f" Checking vessel: {item.get('label')}")  # Debug print
            if item.get("label") == vase:
                if parameter in item:
                    item[parameter] = item[parameter] + add_value
                    print(f"Parameter '{parameter}' of vessel '{vase}' updated to: {item[parameter]}")
                    found = True
                else:
                    print(f"Error: Parameter '{parameter}' not found in vessel '{vase}'.")
                break

        if not found:
            print(f"Error: Vessel '{vase}' not found in YAML.")

        # Saves the updated YAML to the updated_file
        with open(updated_file, "w", encoding="utf-8") as f:
            yaml.dump(yaml_data, f, default_flow_style=False, allow_unicode=True)
        print(f"Updated file saved in: {updated_file}")


    def openBF(self, file, output_dir):
        """Runs openBF"""
        # Initializes the Julia environment
        jl = julia.Julia(compiled_modules=False)

        # Loads the required Julia packages
        Main.eval("using Pkg")

        # Loads the openBF package if it is not installed
        Main.eval(""" 
                            if !haskey(Pkg.dependencies(), Base.UUID("e815b1a4-10eb-11ea-25f1-272ff651e618"))
                            Pkg.add(url="https://github.com/INSIGNEO/openBF.git")
                            end
                        """)

        # Runs hemodynamic simulation
        Main.eval(""" 
                                    using openBF
                                    function pyopenBF(file, output_dir)
                                        run_simulation(file, verbose=true, save_stats=true, savedir=output_dir)
                                        println("openBF output saved in: $output_dir")
                                    end
                                """)

        # Calls Julia function from Python
        Main.pyopenBF(file, output_dir)
        return

    def stack_last_files(self, vessel, variables, data_dir):
        """Stacks the openBF output for each vessel in the order of the variables from top to bottom
        and saves it to a .last file"""
        data_list = []

        for var in variables:
            file_path = os.path.join(data_dir, f"{vessel}_{var}.last")

            # Checks if file exists
            if not os.path.exists(file_path):
                raise RuntimeError(
                        f"Error: Expected file not generated by openBF: {file_path}\n"
                        "Simulation failed. Check the parameters or the Julia output."
                    )
            
            # Reads data from the .last file
            data = np.loadtxt(file_path)
            data_list.append(data)

        # Stacks files vertically (A, P, Q, u)
        stacked_data = np.vstack(data_list)

        # Calculates the spectral norm (its largest singular value)
        spectral_norm = np.linalg.norm(stacked_data, 2)

        # Saves the stacked file
        stacked_file = os.path.join(data_dir, f"{vessel}_stacked.last")
        np.savetxt(stacked_file, stacked_data, fmt="%.14e")

        # Saves the spectral norm 
        spectral_file = os.path.join(data_dir, f"{vessel}_spectral_norm.last")
        np.savetxt(spectral_file, np.array([spectral_norm]), fmt="%.14e")

        print(f"Saved file: {stacked_file}")
        print(f"Saved file: {spectral_file}")

    def partial_deriv_files(self, vessel, base_dir, updated_dir, del_dir, parameter):
        """
        Subtracts the stacked files of base_dir from the stacked files of updated_dir,
        divides by the delta parameter and saves the result in del_dir.
        """

        # Calculates the parameter difference
        delta_value = self.add_value
        print(f"Parameter '{parameter}' difference: {delta_value}")

        if delta_value == 0:
            print("Warning: Parameter difference is zero. Avoiding division by zero.")
            return

        # Creates the output directory if it does not exist
        os.makedirs(del_dir, exist_ok=True)

        base_file_path = os.path.join(base_dir, f"{vessel}_stacked.last") #!!!
        updated_file_path = os.path.join(updated_dir, f"{vessel}_stacked.last")
        del_file_path = os.path.join(del_dir, f"{vessel}_del_{parameter}_delta={delta_value}.last")

        # Checks if both files exist
        if not os.path.exists(base_file_path) or not os.path.exists(updated_file_path):
            raise SystemExit(f"Error: Files for {vessel} not found. Execution stopped.")

        # Loads the files .last
        base_data = np.loadtxt(base_file_path)
        updated_data = np.loadtxt(updated_file_path)

        # Checks if the dimensions are compatible
        if base_data.shape != updated_data.shape:
            print(f"Error: Incompatible dimensions for {vessel}: {base_data.shape} vs {updated_data.shape}.")

        # Performs subtraction and division by delta_value
        del_data = (updated_data - base_data) / delta_value

        # Saves the result
        np.savetxt(del_file_path, del_data, fmt="%.14e")
        print(f"Partial derivatives file saved: {del_file_path}")


    def plot_openBF(self, vessel, data_dir):
        """ Plots the openBF output graphs (Pressure/Area/Flow/Velocity vs. Time)
        and saves them in data_dir.
        """

        variables = ["P", "u"]

        # Creates dictionary to store dataframes
        data = {var: [] for var in variables}

        # Reads files and store in dictionary
        for var in variables:
            file_path = os.path.join(data_dir, f"{vessel}_{var}.last")
            df = pd.read_csv(file_path, delim_whitespace=True, header=None)
            df.columns = ["Time", "Length 1", "Length 2", "Length 3", "Length 4", "Length 5"]
            data[var].append(df)

            # data = {
            #   "P": [df_vase1_P, df_vase2_P, df_vase3_P],
            #   "u": [df_vase1_u, df_vase2_u, df_vase3_u]
            # }

        # Creates folder for saving plots
        plots_dir = os.path.join(data_dir, "plots")
        os.makedirs(plots_dir, exist_ok=True)

        # Plots graphs
        for var, label, unit in zip(["P", "u"],
                                    ["Pressure", "Velocity"],
                                    ["mmHg", "m/s"]):
            fig, axs = plt.subplots(3, 1, figsize=(10, 14))

            df = data[var][0]
            for j in range(1, 6):  # Colunas dos Nós (1 a 5)
                axs.scatter(df["Time"], df[f"Length {j}"], label=f"Length {j}")
                axs.plot(df["Time"], df[f"Length {j}"], linestyle='-', alpha=0.6)
            axs.set_title(f"{vessel.capitalize()}: {label} vs Time")
            axs.set_xlabel("Time (s)")
            axs.set_ylabel(f"{label} ({unit})")
            axs.grid(True)
            axs.legend()

            fig.subplots_adjust(hspace=0.7)

            # Saves plots in .png .svg and .pdf formats
            plot_path = os.path.join(plots_dir, f"{var}_plot")

            plt.savefig(f"{plot_path}.png", dpi=300)
            plt.savefig(f"{plot_path}.svg")
            with open(f"{plot_path}.pkl", "wb") as f:
                pickle.dump(fig, f)

            plt.close(fig)

            print(f"Plots saved: {plot_path}.png, {plot_path}.svg, {plot_path}.pkl")

    def stack_partial_derivatives(self, knumber, vessel, delta_dict, output_path):
        """
        Horizontally stacks only the 4th column of the partial derivative matrices for each vessel.

        Parameters:
        delta_dict (dict): Dictionary with the deltas used in each parameter.
        output_path (str): Path where the stacked files will be saved.
        """
        parameters = ["h0", "L", "R0", "Rp", "Rd", "E"]

        # Filters parameters with delta != 0
        valid_parameters = [param for param in parameters if delta_dict[param] != 0]

        for param in parameters:
            if delta_dict[param] == 0:
                print(
                    f"Warning: Variation of the parameter '{param}' is zero. It will be excluded from the Jacobian matrix.")

        if not os.path.exists(output_path):
            os.makedirs(output_path)

        matrices = []

        for param in valid_parameters:
            delta = delta_dict[param]
            file_path = os.path.join(openBF_dir, f"partial_deriv_{param}",
                                        f"{vessel}_del_{param}_delta={delta}.last")

            if os.path.exists(file_path):
                matrix = np.loadtxt(file_path)
                fourth_column = matrix[:, 3].reshape(-1, 1)  # Selects the 4th column and keeps 2D format
                matrices.append(fourth_column)
            else:
                raise SystemExit(f"Error: File not found - {file_path}. Execution stopped.")

        if matrices:
            stacked_matrix = np.column_stack(matrices)
            output_file = os.path.join(output_path, f"jacobian_k={knumber}_{vessel}_stacked.txt")
            np.savetxt(output_file, stacked_matrix, fmt="%.14e")
            print(f"Stacked matrix saved in: {output_file}")

    def A_matrix(self, beta, vessel, knumber, valid_parameters):
        """ Creates the A_matrix using the Jacobian matrix and saves it in the folder: "A_matrix_beta={beta:.0e}"."""

        file_path = os.path.join(openBF_dir, f"jacobians", f"jacobian_k={knumber}_{vessel}_stacked.txt")
        print_path = os.path.join(openBF_dir, f"A_matrix_beta={beta:.0e}", f"condition_{vessel}_k{knumber}.txt")

        if os.path.exists(file_path):
            Jk = np.loadtxt(file_path) # Loads the Jacobian matrix

            # Creates the diagonal matrix M with the weights of the y matrix (openBF output) 
            scale_factors = np.concatenate([
                np.full(100, 1e-10),  # First 100 elements (pressure): divided by 1e10
                np.full(100, 1e6)     # Last 100 elements (velocity): multiplied by 1e6
            ])
            M = np.diag(scale_factors)
            print(f"Diagonal matrix M ({M.shape}):")
            print(M)

            # Define the regularization weights for each parameter
            weights = {
                "H0": 1,
                "L": 1e-4,
                "R0": 1e-2,
                "Rp": 1e-2,
                "Rd": 1e-2,
                "E": 1e-14
            }

            # Creates the diagonal matrix D based on the valid_parameters order
            D_values = [weights.get(param, 1.0) for param in valid_parameters]
            D = np.diag(D_values)
            print("Diagonal matrix D:")
            print(D)

            # Regularizing the solution of the LS-problem
            JkT_M_Jk = Jk.T @ M @ Jk # Jacobian transpose times the Jacobian with M matrix
            A_matrix = JkT_M_Jk + beta * D 

            # Checks if it is invertible
            # Calculates the rank
            u_Jk, s_Jk, vh_Jk = np.linalg.svd(Jk)
            rank_Jk = np.sum(s_Jk > 1e-12)  # tolerance
            u_JkT_M_Jk, s_JkT_M_Jk, vh_JkT_M_Jk = np.linalg.svd(JkT_M_Jk)
            rank_JkT_M_Jk = np.sum(s_JkT_M_Jk > 1e-12)  # tolerance
            u_A, s_A, vh_A = np.linalg.svd(A_matrix)
            rank_A = np.sum(s_A > 1e-12)  # tolerance


            if rank_Jk < min(Jk.shape):
                print("A matriz é rank-deficient")


            # Checks the singularity of matrices
            matrices = [
                (Jk, rank_Jk, f"Jk matrix"),
                (JkT_M_Jk, rank_JkT_M_Jk, f"JkT @ M @ Jk matrix"),
                (A_matrix, rank_A, f"(JkT @ M @ Jk + beta * D) matrix")
            ]

            # Prints and saves in a file the condition number and the status of the matrices
            os.makedirs(os.path.dirname(print_path), exist_ok=True)

            with open(print_path, "w") as log:
                for matrix, rank, desc in matrices:
                    msg_cond = f"{desc} rank: {rank:.2e}"
                    msg_status = (
                        f"Warning: The {desc} is rank-deficient (non-invertible)."
                        if rank < min(matrix.shape)
                        else f"The {desc} is full-rank (invertible)."
                    )
                    print(msg_cond)
                    print(msg_status)
                    log.write(msg_cond + "\n")
                    log.write(msg_status + "\n")
                    log.write("\n")
                print(f"beta = {beta:.0e}")
                log.write(f"beta = {beta:.0e} \n")

            # Saves A matrix 
            output_dir = os.path.join(openBF_dir, f"A_matrix_beta={beta:.0e}")
            os.makedirs(output_dir, exist_ok=True)  # Creates the folder if it does not exist

            output_file = os.path.join(output_dir, f"A_matrix_{vessel}.txt")
            np.savetxt(output_file, A_matrix, fmt="%.14e")
            print(f"A matrix saved in: {output_file}")

        else:
            raise SystemExit(f"Error: File not found - {file_path}. Execution stopped.")

    def B_matrix(self, beta, vessel, knumber):

        # Path to the jacobian matrix file
        file_path = os.path.join(openBF_dir, f"jacobians", f"jacobian_k={knumber}_{vessel}_stacked.txt")

        if os.path.exists(file_path):
            Jk = np.loadtxt(file_path) # Loads the Jacobian matrix
        else:
            raise SystemExit(f"Error: Jacobian matrix file not found - {file_path}")

        # Loads the data from the patient openBF output - ym
        patient_output = os.path.join(openBF_dir, f"ym - openBF output paciente", f"{vessel}_stacked.last")

        if not os.path.exists(patient_output):
            raise SystemExit(f"Error: Patient output file not found - {patient_output}")

        data = np.loadtxt(patient_output)
        patient_data = data[:, 3].reshape(-1, 1) # Only takes the 3rd knot

        # Loads the simulation output corresponding to the guess
        yk_output = os.path.join(openBF_dir, f"y{knumber} - openBF output iteration {knumber}", f"{vessel}_stacked.last")

        if not os.path.exists(yk_output):
            raise SystemExit(f"Error: Output file for iteration {knumber} not found - {yk_output}")

        data = np.loadtxt(yk_output)
        yk_data = data[:, 3].reshape(-1, 1)  # Only takes the 3rd knot

        R_matrix = patient_data - yk_data

        # Creates the diagonal matrix M with the weights of the y matrix (openBF output) 
        scale_factors = np.concatenate([
            np.full(100, 1e-10),  # First 100 elements (pressure): divided by 1e10
            np.full(100, 1e6)     # Last 100 elements (velocity): multiplied by 1e6
        ])
        M = np.diag(scale_factors)

        # Creates the B matriz
        B = Jk.T @ M @ R_matrix

        # Where the B matrix files will be
        B_dir = os.path.join(openBF_dir, "B_matrix")
        os.makedirs(B_dir, exist_ok=True)

        # Saves the B matrix in a file
        B_file = os.path.join(B_dir, f"B_matrix_{vessel}_beta={beta:.0e}.last")
        np.savetxt(B_file, B, fmt="%.14e")
        print(f"B matrix saved: {B_file}")

    def Pdk(self, vessel, delta_dict, param_directory, yaml_file):
        """Loads the parameters of a yaml file and saves it in a directory."""

        Pdk = {vessel: []}

        # Creates a vector with the parameter values corresponding to the guess
        parameters = ["h0", "L", "R0", "Rp", "Rd", "E"]

        # Filters parameters with delta != 0
        valid_parameters = [param for param in parameters if delta_dict[param] != 0]

        # Loads YAML from k_file
        k_file = os.path.join(openBF_dir, yaml_file)
        with open(k_file, "r", encoding="utf-8") as f:
            yaml_data = yaml.safe_load(f) or {}

        if "network" not in yaml_data:
            print("Error: The 'network' key was not found in the YAML.")
            return

        found = False  # Flag to know if the vase was found

        for item in yaml_data["network"]:
            if item.get("label") == vessel:
                for parameter in valid_parameters:
                    if parameter in item:
                        value = item[parameter]
                        Pdk[vessel].append(value)
                        found = True
                    else:
                        print(f"Error: Parameter '{parameter}' not found in vessel '{vessel}'.")
                        return

        if not found:
            print(f"Error: Vessel '{vessel}' not found in YAML.")

        # Where the parameters files will be
        file_dir = os.path.join(openBF_dir, param_directory)
        os.makedirs(file_dir, exist_ok=True)

        # Saves the parameters vector in a file
        Pdk_file = os.path.join(file_dir, f"Pdk_{vessel}.last")
        param_array = np.array(Pdk[vessel]).reshape(-1, 1)
        np.savetxt(Pdk_file, param_array, fmt="%.14e")
        print(f"Parameter vector saved: {Pdk_file}")


    def optimized_parameters(self, vessel, alpha, beta, knumber):
        """ Obtains the optimized parameters Pdk+1 and saves them in a file.
        
        Parameters:
            alpha (int): Alpha is the sub-relaxation factor for the Newton step."""

        # Where the matrix of optimized parameters will be
        new_knumber = knumber + 1
        opt_param_dir = os.path.join(openBF_dir, f"optimized_parameters_Pd{new_knumber}")
        os.makedirs(opt_param_dir, exist_ok=True)

        # Loads the parameters of the initial guess (Pdk)
        if knumber == 0:
            param_path = os.path.join(openBF_dir, f"Pd{knumber}", f"Pdk_{vessel}.last")
        else:
            param_path = os.path.join(openBF_dir, f"optimized_parameters_Pd{knumber}",
                                        f"Pdk_{vessel}.last")

        if os.path.exists(param_path):
            param_data = np.loadtxt(param_path).reshape(-1, 1)
        else:
            raise SystemExit(f"Error: Pdk matrix file not found - {param_path}. Execution stopped.")

        # Loads the data from the A matrix
        A_matrix_path = os.path.join(openBF_dir, f"A_matrix_beta={beta:.0e}", f"A_matrix_{vessel}.txt")

        if os.path.exists(A_matrix_path):
            A_data = np.loadtxt(A_matrix_path)
        else:
            raise SystemExit(f"Error: A matrix file not found - {A_matrix_path}. Execution stopped.")

        # Loads the data from the B matrix
        B_matrix_path = os.path.join(openBF_dir, "B_matrix", f"B_matrix_{vessel}_beta={beta:.0e}.last")

        if os.path.exists(B_matrix_path):
            B_data = np.loadtxt(B_matrix_path).reshape(-1, 1)

        else:
            raise SystemExit(f"Error: B matrix file not found - {B_matrix_path}. Execution stopped.")

        # Creates the optimized parameters (Pd(k+1)) matrix
        deltaP_matrix = np.linalg.solve(A_data,B_data)
        opt_param_data = param_data + alpha * deltaP_matrix
        print(f"Optimized parameters (Pdk+1): {opt_param_data.flatten()}")

        # Saves the optimized parameters matrix in a file
        opt_param_file = os.path.join(opt_param_dir, f"Pdk_{vessel}.last")
        np.savetxt(opt_param_file, opt_param_data, fmt="%.14e")
        print(f"Optimized parameters matrix saved: {opt_param_file}")

        # Checking optimized parameters: prevents negative values
        if np.any(opt_param_data < 0):
            raise ValueError(
                f"Invalid parameter: Negative value detected in {opt_param_data.flatten()}.\n"
                f"Check the value of alpha or the input data."
            )


    def update_yaml_with_optimized_parameters(self, vessel, delta_dict, base_yaml_path, param_files_dir, output_yaml_path):
        # Updates the input YAML using the optimized parameters saved in separate files.

        parameters = ["h0", "L", "R0", "Rp", "Rd", "E"]

        # Filters parameters with delta != 0
        valid_parameters = [param for param in parameters if delta_dict[param] != 0]

        # Loads the YAML file
        with open(base_yaml_path, "r", encoding="utf-8") as f:
            yaml_data = yaml.safe_load(f) or {}

        if "network" not in yaml_data:
            print("Error: 'network' key not found in YAML.")
            return

        # Loads the file with the optimized parameters
        param_file = os.path.join(param_files_dir, f"Pdk_{vessel}.last")

        if os.path.exists(param_file):
            new_params = np.loadtxt(param_file)
        else:
            print(f"Error: Parameter file not found - {param_file}. Skipping {vessel}.")
            return

        # Ensures that new_params is a vector (not an array)
        new_params = np.atleast_1d(new_params)

        if len(new_params) != len(valid_parameters):
            print(
                f"Error: Number of parameters mismatch for {vessel}. Expected {len(valid_parameters)}, got {len(new_params)}.")

        # Updates the YAML values
        for item in yaml_data["network"]:
            if item.get("label") == vessel:
                for i, param in enumerate(valid_parameters):
                    item[param] = float(new_params[i])
                print(f"Updated parameters for {vessel}: {new_params}")
                break
        else:
            print(f"Warning: Vessel {vessel} not found in YAML.")

        # Saves the new YAML file
        with open(output_yaml_path, "w", encoding="utf-8") as f:
            yaml.dump(yaml_data, f, default_flow_style=False, allow_unicode=True)

        print(f"Updated YAML saved in: {output_yaml_path}")

    def plot_error(self, vessel, beta, data_dir, valid_parameters, knumber_max):
        # Plots the total error vs. iteration

        plt.close('all')
        Y_error_append = []
        param_error_append = []

        # Creates the diagonal matrix M with the weights of the y matrix (openBF output) 
        scale_factors = np.concatenate([
            np.full(100, 1e-10),  # First 100 elements (pressure): divided by 1e10
            np.full(100, 1e6)     # Last 100 elements (velocity): multiplied by 1e6
        ])
        M = np.diag(scale_factors)

        
        # Define the regularization weights for each parameter
        weights = {
            "H0": 1.0,
            "L": 1e-4,
            "R0": 1e-2,
            "Rp": 1e-2,
            "Rd": 1e-2,
            "E": 1e-14
        }

        # Creates the diagonal matrix D based on the valid_parameters order
        D_values = [weights.get(param, 1.0) for param in valid_parameters]
        D = np.diag(D_values)


        for knumber in range(0, knumber_max + 1):

            kplus = knumber + 1

            # Files paths
            patient_file = os.path.join(openBF_dir, "ym - openBF output paciente", f"{vessel}_stacked.last")
            yk_file = os.path.join(openBF_dir, f"y{knumber} - openBF output iteration {knumber}", f"{vessel}_stacked.last")
            Jk_file = os.path.join(openBF_dir, f"jacobians", f"jacobian_k={knumber}_{vessel}_stacked.txt")
            kplus_param_file = os.path.join(openBF_dir, f"optimized_parameters_Pd{kplus}", f"Pdk_{vessel}.last")
            if knumber == 0:
                k_param_file = os.path.join(openBF_dir, "Pd0", f"Pdk_{vessel}.last")
            else:
                k_param_file = os.path.join(openBF_dir, f"optimized_parameters_Pd{knumber}", f"Pdk_{vessel}.last")

            # Checks if files exist
            if not os.path.exists(patient_file):
                raise SystemExit(f"Error: File {patient_file} not found. Execution stopped.")
            if not os.path.exists(yk_file):
                raise SystemExit(f"Error: File {yk_file} not found. Execution stopped.")
            if not os.path.exists(Jk_file):
                raise SystemExit(f"Error: File {Jk_file} not found. Execution stopped.")
            if not os.path.exists(kplus_param_file):
                raise SystemExit(f"Error: File {kplus_param_file} not found. Execution stopped.")
            if not os.path.exists(k_param_file):
                raise SystemExit(f"Error: File {k_param_file} not found. Execution stopped.")

            # Loads files ignoring comments
            patient_data = np.loadtxt(patient_file, comments="#")[:, 3] # Takes only the 4ª column
            yk_data = np.loadtxt(yk_file, comments="#")[:, 3] # Takes only the 4ª column
            Jk_data = np.loadtxt(Jk_file, comments="#")
            kplus_data = np.loadtxt(kplus_param_file, comments="#")
            k_data = np.loadtxt(k_param_file, comments="#")

            # Creates deltaP matrix
            deltaP_matrix = kplus_data - k_data

            # Calculates the squared error of the output of iteration k with respect to the patient output
            Y = patient_data - yk_data + Jk_data @ deltaP_matrix
            Y_error = Y.T @ M @ Y

            # Stores it to plot
            Y_error_append.append(Y_error)

            # Calculates the squared error of the parameters
            param_error = beta * deltaP_matrix.T @ D @ deltaP_matrix

            # Stores it to plot
            param_error_append.append(param_error)


        # Iterations: 0 to knumber_max
        iterations = np.arange(0, knumber_max + 1)

        # Plots directory
        plots_dir = os.path.join(data_dir, f"iteration_plots_beta={beta:.0e}")
        os.makedirs(plots_dir, exist_ok=True)

        # === 1. y_error plot ===
        fig1 = plt.figure(figsize=(8, 5))
        plt.plot(iterations, Y_error_append, marker='o', linestyle='-', color='tab:red')
        plt.xlabel('Iteration')
        plt.ylabel('y quadratic error (mid-point)')
        plt.title(f'Squared error of yk with respect to the patient output - {vessel}')
        plt.grid(True)
        plt.tight_layout()

        plot_path1 = os.path.join(plots_dir, f"y_error_plot")
        plt.savefig(f"{plot_path1}.png", dpi=300)
        plt.savefig(f"{plot_path1}.svg")
        with open(f"{plot_path1}.pkl", "wb") as f:
            pickle.dump(fig1, f)
        plt.close(fig1)

        # === 2. param_error plot ===
        fig2 = plt.figure(figsize=(8, 5))
        plt.plot(iterations, param_error_append, marker='s', linestyle='-', color='tab:blue')
        plt.xlabel('Iteration')
        plt.ylabel('Parameters quadratic error')
        plt.title(f'Squared error of parameters - {vessel}')
        plt.grid(True)
        plt.tight_layout()

        plot_path2 = os.path.join(plots_dir, f"param_error_plot")
        plt.savefig(f"{plot_path2}.png", dpi=300)
        plt.savefig(f"{plot_path2}.svg")
        with open(f"{plot_path2}.pkl", "wb") as f:
            pickle.dump(fig2, f)
        plt.close(fig2)

        # === 3. Sum plot ===
        total_error_append = np.array(Y_error_append) + np.array(param_error_append)

        fig3 = plt.figure(figsize=(8, 5))
        plt.plot(iterations, total_error_append, marker='^', linestyle='-', color='tab:green')
        plt.xlabel('Iteration')
        plt.ylabel('Total quadratic error')
        plt.title(f'Sum of parameters and y errors - {vessel}')
        plt.grid(True)
        plt.tight_layout()

        plot_path3 = os.path.join(plots_dir, f"total_error_plot")
        plt.savefig(f"{plot_path3}.png", dpi=300)
        plt.savefig(f"{plot_path3}.svg")
        with open(f"{plot_path3}.pkl", "wb") as f:
            pickle.dump(fig3, f)
        plt.close(fig3)

        # Confirmation in the terminal
        print("Plots saved:")
        print(f" - {plot_path1}.png, .svg, .pkl")
        print(f" - {plot_path2}.png, .svg, .pkl")
        print(f" - {plot_path3}.png, .svg, .pkl")


    def plot_iter(self, vessel, beta, delta_dict, data_dir: str, knumber_max: int):
        """Plota os parâmetros com delta ≠ 0 e suas diferenças relativas em relação ao paciente."""

        plt.close('all')

        file_template = 'Pdk_{}.last'
        plots_dir = os.path.join(data_dir, f"iteration_plots_beta={beta:.0e}")
        os.makedirs(plots_dir, exist_ok=True)

        patient_parameters = "Pm"
        patient_yaml = "problema_inverso - Paciente.yaml"
        self.Pdk(vessel, delta_dict, patient_parameters, patient_yaml)

        file_name = file_template.format(vessel)
        folders = ['Pd0'] + [f'optimized_parameters_Pd{i}' for i in range(1, knumber_max + 1)]

        all_parameters = ["h0", "L", "R0", "E", "Rp", "Rd"]
        param_labels = {
            "h0": "h0 - Wall thickness [m]",
            "L": "L - Length [m]",
            "R0": "R0 - Lumen radius [m]",
            "E": "E - Elastic modulus [Pa]",
            "Rp": "Rp - Proximal radius [m]",
            "Rd": "Rd - Distal radius [m]"
        }

        valid_params = [p for p in all_parameters if delta_dict.get(p, 0) != 0]
        param_series = {p: [] for p in valid_params}

        for folder in folders:
            file_path = os.path.join(self.openBF_dir, folder, file_name)
            if not os.path.isfile(file_path):
                raise SystemExit(f"Error: File not found at {file_path}. Execution stopped.")

            dados = np.loadtxt(file_path).flatten()
            for i, p in enumerate(valid_params):
                param_series[p].append(dados[i])

        patient_path = os.path.join(self.openBF_dir, patient_parameters, file_name)
        if not os.path.isfile(patient_path):
            raise SystemExit(f"Error: Patient file not found at {patient_path}. Execution stopped.")

        patient_data = np.loadtxt(patient_path).flatten()
        patient_vals = {p: patient_data[i] for i, p in enumerate(valid_params)}

        iterations = np.arange(len(folders))

        # Separar E dos outros
        params_main = [p for p in valid_params if p != "E"]
        has_E = "E" in valid_params

        # Plot absoluto (sem E)
        if params_main:
            fig1, ax1 = plt.subplots(figsize=(10, 6))
            for p in params_main:
                y = param_series[p]
                label = param_labels.get(p, p)
                line, = ax1.plot(iterations, y, 'o-', label=label)
                ax1.axhline(patient_vals[p], linestyle='--', linewidth=2,
                            color=line.get_color(), label=f'Patient {p}')
            ax1.set(title=f'Parameters vs Iterations - {vessel}', xlabel='Iterations', ylabel='Parameter Values')
            ax1.grid(True)
            ax1.legend()
            plot_path = os.path.join(plots_dir, f"{vessel}_plot_all_params")
            fig1.savefig(f"{plot_path}.png", dpi=300)
            fig1.savefig(f"{plot_path}.svg")
            with open(f"{plot_path}.pkl", "wb") as f:
                pickle.dump(fig1, f)
            plt.close(fig1)
            print(f"Saved: {plot_path}.png, .svg, .pkl")

        # Plot exclusivo para E
        if has_E:
            figE, axE = plt.subplots(figsize=(10, 6))
            axE.yaxis.set_major_formatter(ScalarFormatter(useMathText=False))
            axE.ticklabel_format(style='plain', axis='y')
            yE = param_series["E"]
            axE.plot(iterations, yE, 'o-', color='tab:red', label=param_labels["E"])
            axE.axhline(patient_vals["E"], linestyle='--', linewidth=2, color='tab:red', label='Patient E')
            axE.set(title=f'Elastic Modulus vs Iterations - {vessel}', xlabel='Iterations',
                    ylabel='Elastic modulus [Pa]')
            axE.grid(True)
            axE.legend()
            plot_path_E = os.path.join(plots_dir, f"{vessel}_plot_E_only")
            figE.savefig(f"{plot_path_E}.png", dpi=300)
            figE.savefig(f"{plot_path_E}.svg")
            with open(f"{plot_path_E}.pkl", "wb") as f:
                pickle.dump(figE, f)
            plt.close(figE)
            print(f"Saved: {plot_path_E}.png, .svg, .pkl")

        # Plot diferenças relativas (todos juntos, inclusive E)
        fig2, ax2 = plt.subplots(figsize=(10, 6))
        for p in valid_params:
            vals = np.array(param_series[p])
            ref = patient_vals[p]
            diff = (vals - ref) / ref
            ax2.plot(iterations, diff, marker='o', label=param_labels.get(p, p))
        ax2.axhline(0, color='gray', linestyle='--', linewidth=1)
        ax2.set(title=f'Relative Difference of Parameters - {vessel}', xlabel='Iterations', ylabel='Relative Difference')
        ax2.grid(True)
        ax2.legend()
        rel_diff_path = os.path.join(plots_dir, f"{vessel}_relative_diff_plot")
        fig2.savefig(f"{rel_diff_path}.png", dpi=300)
        fig2.savefig(f"{rel_diff_path}.svg")
        with open(f"{rel_diff_path}.pkl", "wb") as f:
            pickle.dump(fig2, f)
        plt.close(fig2)
        print(f"Saved: {rel_diff_path}.png, .svg, .pkl")


    def file_openBF(self, yaml_file, output_folder_name):
        """Runs openBF in Julia for the specified YAML file;
            stacks the output values;
            and plots the graphs (Pressure/Area/Flow/Velocity vs. Time)."""

        # Where the yaml_file output files will be
        file_dir = os.path.join(openBF_dir, output_folder_name)
        os.makedirs(file_dir, exist_ok=True)

        # Runs openBF to yaml_file
        self.openBF(yaml_file, file_dir)

        # Stacking order of vessels and variables
        vessels = ["vase1", "vase2", "vase3"]
        variables = ["P", "u"]

        # Stack openBF outputs for each vessel individually
        # Plots the simulation output graphs and saves them
        for vessel in vessels:
            self.stack_last_files(vessel, variables, file_dir)
            #self.plot_openBF(vessel, file_dir)


    def updated_openBF(self, knumber, vase, parameter, add_value):
        """ Updates the value of a parameter within a specific vessel;
        runs openBF in Julia for the updated YAML;
        stacks the output values, calculates the partial derivatives with respect to the modified parameter;
        and plots the graphs (Pressure/Area/Flow/Velocity vs. Time)."""

        # Updates the YAML file to the specified parameter
        self.update_yaml(knumber, vase, parameter, add_value)

        # Where the k_file output files are
        base_dir = os.path.join(openBF_dir, f"y{knumber} - openBF output iteration {knumber}")
        os.makedirs(base_dir, exist_ok=True)
        # Where the updated_file output files will be
        updated_dir = os.path.join(openBF_dir, f"openBF_updated_{vase}_{parameter}")
        os.makedirs(updated_dir, exist_ok=True)

        # Runs openBF to updated_file
        updated_file = os.path.join(openBF_dir, f"updated_{parameter}.yaml")
        self.openBF(updated_file,updated_dir)

        # Stacking order of vessels and variables
        vessels = ["vase1", "vase2", "vase3"]
        variables = ["P", "u"]

        # Stack openBF outputs for each vessel individually
        for vessel in vessels:
            self.stack_last_files(vessel, variables, updated_dir)

        # Path to the partial derivatives directory
        del_dir = os.path.join(openBF_dir, f"partial_deriv_{parameter}")

        # Calculates and creates the partial derivatives files
        self.partial_deriv_files(vase, base_dir, updated_dir, del_dir, parameter)

        # Plots the simulation output graphs and saves them
        #self.plot_openBF(vessel, updated_dir)

    def iteration(self, knumber, vase, alpha, beta, add_h0, add_L, add_R0, add_Rp, add_Rd, add_E):
        # ATUALIZAR DESCRICAO """Creates the Jacobian pseudoinverse matrix considering the increments specified for each parameter,
        #multiplies it to the R matrix and generates the optimized parameters."""
        add_values = {"h0": add_h0, "L": add_L, "R0": add_R0, "Rp": add_Rp, "Rd": add_Rd, "E": add_E}

        print(f"\n=== Starting iteration {knumber} with beta = {beta:.1e} ===\n")

        # Filters parameters with delta != 0
        valid_parameters = [param for param in add_values if add_values[param] != 0]
        print (f"The valid parameters are: {valid_parameters}.")


        if knumber == 0:
            k_yaml_file = os.path.join(openBF_dir, self.k0_file)

            # Checks if file exists
            if not os.path.exists(k_yaml_file):
                raise SystemExit(f"Error: File {k_yaml_file} not found. Execution stopped.")

            # Runs openBF to 0-iteration YAML file
            self.file_openBF(k_yaml_file, f"y{knumber} - openBF output iteration {knumber}")

        for parameter in valid_parameters:
            self.updated_openBF(knumber, vase, parameter, add_values[parameter])

        # Path to the Jacobian matrices directory
        output_path = os.path.join(openBF_dir, f"jacobians")
        self.stack_partial_derivatives(knumber, vase, add_values, output_path)

        # Creates the Pd0 matrix (parameters of the k-iteration yaml)
        if knumber == 0:
            yaml_file = self.k0_file
            param_directory = "Pd0"

            self.Pdk(vase, add_values, param_directory, yaml_file)

        # Creates the pseudoinverse matrix
        self.A_matrix(beta, vase, knumber, valid_parameters)

        # Creates the B matrix
        self.B_matrix(beta, vase, knumber)

        # Creates the optimized parameters matrix
        self.optimized_parameters(vase, alpha, beta, knumber)

        # Updates YAML with optimized parameters
        if knumber == 0:
            base_yaml_path = os.path.join(openBF_dir, self.k0_file)
        else:
            base_yaml_path = os.path.join(openBF_dir, f"problema_inverso - k={knumber}.yaml")
        opt_param_files_dir = os.path.join(openBF_dir, f"optimized_parameters_Pd{knumber+1}")
        opt_output_yaml_path = os.path.join(openBF_dir, f"problema_inverso - k={knumber+1}.yaml")

        # Checks if file exists
        if not os.path.exists(base_yaml_path):
            raise SystemExit(f"Error: File {base_yaml_path} not found. Execution stopped.")

        self.update_yaml_with_optimized_parameters(vase, add_values, base_yaml_path, opt_param_files_dir, opt_output_yaml_path)

        # Runs openBF to the new/optimized yaml file
        self.file_openBF(opt_output_yaml_path, f"y{knumber+1} - openBF output iteration {knumber+1}")


    def search_opt(self, vase, alpha, beta, add_h0, add_L, add_R0, add_Rp, add_Rd, add_E, knumber_max):

        add_values = {"h0": add_h0, "L": add_L, "R0": add_R0, "Rp": add_Rp, "Rd": add_Rd, "E": add_E}
        parameters = ["h0", "L", "R0", "Rp", "Rd", "E"]

        # Filters parameters with delta != 0
        valid_parameters = [param for param in parameters if add_values[param] != 0]

        # Starts chronometer
        start = time.time()

        # Runs iteration for k from 0 to knumber_max
        for knumber in range(0, knumber_max + 1):
            self.iteration(knumber, vase, alpha, beta, add_h0, add_L, add_R0, add_Rp, add_Rd, add_E)

        # Plots RMSE for k from 0 to knumber_max
        self.plot_error(vase, beta, openBF_dir, valid_parameters, knumber_max)

        # Plots the parameters for each iteration
        self.plot_iter(vase, beta, add_values, openBF_dir, knumber_max)

        # Ends chronometer and prints time
        end = time.time()
        minutes = (end - start)/60
        print(f"Elapsed time: {minutes:.3f} minutes.")




# Application
if __name__ == "__main__":

    patient_file = "C:/Users/Reinaldo/Documents/problema_inverso_results_openbf_vase1/problema_inverso - Paciente.yaml"
    k0_file = "C:/Users/Reinaldo/Documents/problema_inverso_results_openbf_vase1/problema_inverso - k=0 - fixed_vessels_2and3.yaml"
    openBF_dir = "C:/Users/Reinaldo/Documents/problema_inverso_results_openbf_vase1"

    updater = OPENBF_Jacobian(patient_file, k0_file, openBF_dir)

    # Runs openBF to patient file
    updater.file_openBF(patient_file, "ym - openBF output paciente")

    # Searches optimized parameters
    # search_opt(self, vase, alpha, beta, add_h0, add_L, add_R0, add_Rp, add_Rd, add_E, knumber_max)
    
    exponents = np.arange(-8, 3)  # 3 is exclusive, so it goes up to 2
    beta_values = 10.0 ** exponents
    alpha = 0.3
    for beta in beta_values:
        updater.search_opt("vase1", alpha, beta, 0.00001, 0.001, 0.0001, 0, 0, 0, 20)


